local GLASS_SLOT = 2

local function victory()
    print("We finished the maze!")
    turtle.up()
    -- Spin around to celebrate
    for _ = 1, 4 do
        turtle.turnRight()
    end    
end

local function look()
    -- Check the block underneath for the end (yellow) marker
    local ok, data = turtle.inspectDown()
    
    -- The end condition is finding any block with 'yellow' in its name (e.g., yellow_concrete)
    if ok and data.name and data.name:find("yellow") then
        victory()
        return true
    end    
    
    return false
end

local function inspect_up()
    local ok, data = turtle.inspectUp()
    -- We look for "glass" in the block's name property (our intersection marker)
    return ok and data.name and data.name:find("glass")
end

local function place_glass()
    local current_slot = turtle.getSelectedSlot()
    turtle.select(GLASS_SLOT)
    local success = turtle.placeUp()
    turtle.select(current_slot) -- Return to the previous slot
    return success
end

-- === Directional Detection Helpers ===

local function detect_right()
    turtle.turnRight()
    local is_blocked = turtle.detect()
    turtle.turnLeft() -- Turn back to original orientation
    return is_blocked
end

local function detect_left()
    turtle.turnLeft()
    local is_blocked = turtle.detect()
    turtle.turnRight() -- Turn back to original orientation
    return is_blocked
end

local function detect_behind()
    -- This function inspects the position behind the turtle without changing its final facing direction.
    
    -- 1. Turn 180 degrees
    turtle.turnLeft()
    turtle.turnLeft()

    -- 2. Check if the path is clear
    local is_blocked = turtle.detect()
    local is_clear = not is_blocked

    -- 3. Check the ground block
    local ok_down, data_down = turtle.inspectDown()
    local is_yellow_concrete = false
    
    if ok_down and data_down.name and data_down.name:find("yellow") then
        is_yellow_concrete = true
    end

    -- 4. Turn 180 degrees back to the original direction
    turtle.turnRight()
    turtle.turnRight()

    -- Return if the path is clear and the ground is yellow
    return is_clear, is_yellow_concrete
end

-- === Setup and Main Loop ===

-- Fuel check
turtle.select(1) -- Select fuel slot (slot 1)
-- Attempt to refuel if needed (use 10 coal/fuel items)
if turtle.getFuelLevel() < 10 then
    print("Attempting to refuel...")
    turtle.refuel(10)
end

if turtle.getFuelLevel() < 5 then
    print("WARNING: Low on fuel. Ensure fuel is in slot 1.")
end


while true do
    -- 1. Check for win condition
    local done = look()
    if done then    
        return
    end
    
    local moved = false
    
    -- Check surrounding paths
    local is_front_clear = not turtle.detect()
    local is_right_clear = not detect_right()
    local is_left_clear = not detect_left()

    -- === Movement Logic (Prioritizing Right-Hand Rule and Marker Avoidance) ===

    -- A. If we see a glass marker above, that means we are backtracking into a 3-way intersection.
    -- We avoid that by turning right and moving forward (RHR restart).
    if inspect_up() then
        print("Marker found above (Glass). Turning right to avoid backtracking.")
        turtle.turnRight()
        if turtle.forward() then    
            moved = true
        end

    -- B. 3-Way Intersection: Place marker and move straight
    elseif is_front_clear and is_right_clear and is_left_clear then
        print("3-Way Intersection detected. Placing glass marker and moving straight.")
        place_glass()
        if turtle.forward() then    
            moved = true
        end

    -- C. Right-Hand Rule (RHR) - Priority Right
    elseif is_right_clear then
        print("RHR: Right side clear. Turning right and moving.")
        turtle.turnRight()
        if turtle.forward() then    
            moved = true
        end
    
    -- D. RHR - Priority Front (Only happens if right is blocked)
    elseif is_front_clear then
        print("RHR: Front clear. Moving straight.")
        if turtle.forward() then    
            moved = true
        end

    -- E. RHR - Priority Left (Only happens if right and front are blocked)
    elseif is_left_clear then
        print("RHR: Left side clear. Turning left and moving.")
        turtle.turnLeft()
        if turtle.forward() then    
            moved = true
        end
    
    -- F. Dead End - Incorporate new rule
    else
        -- Check the special condition for moving backward
        local is_back_clear, is_back_yellow = detect_behind()
        
        if is_back_clear and is_back_yellow then
            print("Dead end. SPECIAL BACKTRACK: Path behind is clear and has Yellow Concrete ground.")
            -- Turn 180 degrees and move forward (which is moving backward)
            turtle.turnLeft()
            turtle.turnLeft()
            if turtle.forward() then
                moved = true
            end
        else
            print("Dead end. Standard reversal (180 degrees).")
            -- Standard 180 degree turn
            turtle.turnLeft()
            turtle.turnLeft()
        end
    end

    -- Safety and Fuel Checks
    if not moved and turtle.getFuelLevel() == 0 then
        print("Out of fuel. Halting.")
        return
    end
    
    -- Safety check for unexpected movement failure
    if not moved and (is_front_clear or is_right_clear or is_left_clear) then
        -- This block should only execute if we detected a dead end (G), but we know
        -- if we reached this point, we should have moved if the back condition (F) was met.
        -- This is a final catch-all for errors.
        if not is_back_yellow then
             print("Movement failed unexpectedly despite clear path. Halting.")
             return
        end
    end

end
