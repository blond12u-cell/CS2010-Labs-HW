local GLASS_SLOT = 2

local function victory()
    print("We finished the maze!")
    turtle.up()
    -- Spin around to celebrate
    for _ = 1, 4 do
        turtle.turnRight()
    end    
end

local function look()
    -- Check the block underneath for the end (yellow) marker
    local ok, data = turtle.inspectDown()
    
    -- The end condition is finding any block with 'yellow' in its name (e.g., yellow_concrete)
    if ok and data.name and data.name:find("yellow") then
        victory()
        return true
    end    
    
    return false
end

-- New function: Checks if the block directly below is Red Concrete
local function detect_red_concrete()
    local ok, data = turtle.inspectDown()
    return ok and data.name and data.name:find("red")
end

-- New function: Executes a two-block vertical ascent
local function climb_two_blocks()
    print("Ascending 1st block...")
    local success1 = turtle.up()
    if not success1 then
        print("Climb failed on 1st block.")
        return false
    end
    print("Ascending 2nd block...")
    local success2 = turtle.up()
    if not success2 then
        print("Climb failed on 2nd block.")
        return false
    end
    return true
end

local function inspect_up()
    local ok, data = turtle.inspectUp()
    -- We look for "glass" in the block's name property (our intersection marker)
    return ok and data.name and data.name:find("glass")
end

local function place_glass()
    local current_slot = turtle.getSelectedSlot()
    turtle.select(GLASS_SLOT)
    local success = turtle.placeUp()
    turtle.select(current_slot) -- Return to the previous slot
    return success
end

-- === Directional Detection Helpers ===

local function detect_right()
    turtle.turnRight()
    local is_blocked = turtle.detect()
    turtle.turnLeft() -- Turn back to original orientation
    return is_blocked
end

local function detect_left()
    turtle.turnLeft()
    local is_blocked = turtle.detect()
    turtle.turnRight() -- Turn back to original orientation
    return is_blocked
end

local function detect_behind()
    -- This function inspects the position behind the turtle without changing its final facing direction.
    
    -- 1. Turn 180 degrees
    turtle.turnLeft()
    turtle.turnLeft()

    -- 2. Check if the path is clear
    local is_blocked = turtle.detect()
    local is_clear = not is_blocked

    -- 3. Check the ground block
    local ok_down, data_down = turtle.inspectDown()
    local is_yellow_concrete = false
    
    if ok_down and data_down.name and data_down.name:find("yellow") then
        is_yellow_concrete = true
    end

    -- 4. Turn 180 degrees back to the original direction
    turtle.turnRight()
    turtle.turnRight()

    -- Return if the path is clear and the ground is yellow
    return is_clear, is_yellow_concrete
end

-- === Setup and Main Loop ===

-- Fuel check
turtle.select(1) -- Select fuel slot (slot 1)
-- Attempt to refuel if needed (use 10 coal/fuel items)
if turtle.getFuelLevel() < 10 then
    print("Attempting to refuel...")
    turtle.refuel(10)
end

if turtle.getFuelLevel() < 5 then
    print("WARNING: Low on fuel. Ensure fuel is in slot 1.")
end


while true do
    -- 1. Check for win condition
    local done = look()
    if done then    
        return
    end
    
    local moved = false
    
    -- 2. New Red Concrete Check and Climb Logic (High Priority)
    if detect_red_concrete() then
        print("Red Concrete detected below. Attempting a two-block climb.")
        if climb_two_blocks() then
            moved = true
        else
            -- If climbing failed, we halt as it's a critical failure (blocked or out of fuel)
            print("Climb failed (blocked or out of fuel). Halting.")
            return
        end
    end

    -- Skip RHR/dead end logic if we just climbed successfully
    if not moved then
        
        -- Check surrounding paths for RHR
        local is_front_clear = not turtle.detect()
        local is_right_clear = not detect_right()
        local is_left_clear = not detect_left()

        -- === Movement Logic (Prioritizing Right-Hand Rule and Marker Avoidance) ===

        -- A. If we see a glass marker above, that means we are backtracking into a 3-way intersection.
        if inspect_up() then
            print("Marker found above (Glass). Turning right to avoid backtracking.")
            turtle.turnRight()
            if turtle.forward() then    
                moved = true
            end

        -- B. 3-Way Intersection: Place marker and move straight
        elseif is_front_clear and is_right_clear and is_left_clear then
            print("3-Way Intersection detected. Placing glass marker and moving straight.")
            place_glass()
            if turtle.forward() then    
                moved = true
            end

        -- C. Right-Hand Rule (RHR) - Priority Right
        elseif is_right_clear then
            print("RHR: Right side clear. Turning right and moving.")
            turtle.turnRight()
            if turtle.forward() then    
                moved = true
            end
        
        -- D. RHR - Priority Front (Only happens if right is blocked)
        elseif is_front_clear then
            print("RHR: Front clear. Moving straight.")
            if turtle.forward() then    
                moved = true
            end

        -- E. RHR - Priority Left (Only happens if right and front are blocked)
        elseif is_left_clear then
            print("RHR: Left side clear. Turning left and moving.")
            turtle.turnLeft()
            if turtle.forward() then    
                moved = true
            end
        
        -- F. Dead End - Incorporate special backtrack rule
        else
            -- Check the special condition for moving backward
            local is_back_clear, is_back_yellow = detect_behind()
            
            if is_back_clear and is_back_yellow then
                print("Dead end. SPECIAL BACKTRACK: Path behind is clear and has Yellow Concrete ground.")
                -- Turn 180 degrees and move forward (which is moving backward)
                turtle.turnLeft()
                turtle.turnLeft()
                if turtle.forward() then
                    moved = true
                end
            else
                print("Dead end. Standard reversal (180 degrees).")
                -- Standard 180 degree turn
                turtle.turnLeft()
                turtle.turnLeft()
            end
        end
    end

    -- Safety and Fuel Checks
    if not moved and turtle.getFuelLevel() == 0 then
        print("Out of fuel. Halting.")
        return
    end
    
    -- Safety check for unexpected movement failure
    if not moved and (is_front_clear or is_right_clear or is_left_clear) then
        -- This is a final catch-all for errors where a move was expected but failed.
        print("Movement failed unexpectedly despite clear path. Halting.")
        return
    end

end
